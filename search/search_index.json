{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Page WELCOME YOU ARE I welcome you to my Embedded Linux blog which contains my experience with it and some tutorials about software and hardware skills that I have picked up along the way. Introduction This blog can be summed up in a line: Linux is a cruel mistress and Embedded Linux is that bitch after a break up If you understand the above quote then let's start digging up some Linux Gold , and if you have not then this is not the right place for you please do yourself a favour and readup on Linux and it's relatives and come back with a stronger will . Need of this blog There are a lot of places where tech noobs spread fake information and facts. Herein I try to be as specific as I can about the stuff I write so I don't make the noob mistakes. All the information that I present here is totally according to my experience since I have done all of them individually I can only vouch for their applicability to a limited extent and would be happy to help in case of difficulties.","title":"Home"},{"location":"#home-page","text":"WELCOME YOU ARE I welcome you to my Embedded Linux blog which contains my experience with it and some tutorials about software and hardware skills that I have picked up along the way.","title":"Home Page"},{"location":"#introduction","text":"This blog can be summed up in a line: Linux is a cruel mistress and Embedded Linux is that bitch after a break up If you understand the above quote then let's start digging up some Linux Gold , and if you have not then this is not the right place for you please do yourself a favour and readup on Linux and it's relatives and come back with a stronger will .","title":"Introduction"},{"location":"#need-of-this-blog","text":"There are a lot of places where tech noobs spread fake information and facts. Herein I try to be as specific as I can about the stuff I write so I don't make the noob mistakes. All the information that I present here is totally according to my experience since I have done all of them individually I can only vouch for their applicability to a limited extent and would be happy to help in case of difficulties.","title":"Need of this blog"},{"location":"About/about/","text":"About Prathu Baronia ( alias: praton ) Current Position Fifth Year Undergraduate Embedded Linux Researcher at AJIT Research Group IIT Bombay, India Past Work Experiences Embedded System Engineer at Greetude Energy Systems (May'14 - Jul'14) Other Blogs My Blogspot blog on some of my epiphanies Time Contact Info StackOverflow Github IITB Homepage Personal email My Resume","title":"About"},{"location":"About/about/#about","text":"Prathu Baronia ( alias: praton )","title":"About"},{"location":"About/about/#current-position","text":"Fifth Year Undergraduate Embedded Linux Researcher at AJIT Research Group IIT Bombay, India","title":"Current Position"},{"location":"About/about/#past-work-experiences","text":"Embedded System Engineer at Greetude Energy Systems (May'14 - Jul'14)","title":"Past Work Experiences"},{"location":"About/about/#other-blogs","text":"My Blogspot blog on some of my epiphanies Time","title":"Other Blogs"},{"location":"About/about/#contact-info","text":"StackOverflow Github IITB Homepage Personal email My Resume","title":"Contact Info"},{"location":"Guides/How_to_Embedded_Resume/main/","text":"A Guide to making an Embedded Resume Work Experience Projects Techincal Skills","title":"How to make an Embedded Resume"},{"location":"Guides/How_to_Embedded_Resume/main/#a-guide-to-making-an-embedded-resume","text":"","title":"A Guide to making an Embedded Resume"},{"location":"Guides/How_to_Embedded_Resume/main/#work-experience","text":"","title":"Work Experience"},{"location":"Guides/How_to_Embedded_Resume/main/#projects","text":"","title":"Projects"},{"location":"Guides/How_to_Embedded_Resume/main/#techincal-skills","text":"","title":"Techincal Skills"},{"location":"Guides/How_to_use_mutt/main/","text":"","title":"How to use mutt"},{"location":"OS/BIOS_UEFI/","text":"BIOS The Basic Input/Output System ( BIOS ) is a firmware interface that controls not only the first step of the boot process, but also provides the lowest level interface to peripheral devices. Boot Process When the system boots, the processor looks at the end of system memory for the BIOS program , and runs it. BIOS onducts POST (Power On Self Test). Fetches MBR (Master Boot Record) from first sector of memory. MBR is 512 bytes in size MBR contains machine code instructions for booting the machine, called a boot loader, along with the partition table. BIOS loads Bootloader in RAM , the control is passed to Bootloader after the BIOS loads it. First-stage bootloader is a small machine code binary on the MBR. Its sole job is to locate the second stage boot loader (GRUB) and load the first part of it into memory. Limitations BIOS can boot from only drives of less than or equal to 2 TB . It can't initialize multiple hardware devices at once leading to slow boot processes. Can't support advanced features like netboot . UEFI The Unified Extensible Firmware Interface (UEFI) is designed, like BIOS, to control the boot process (through boot services) and to provide an interface between system firmware and an operating system (through runtime services). Unlike BIOS, it features its own architecture, independent of the CPU, and its own device drivers. UEFI can mount partitions and read certain file systems. Boot Process When an x86 computer equipped with UEFI boots, the interface searches the system storage for a partition labeled with a specific globally unique identifier (GUID) that marks it as the EFI System Partition (ESP) . This partition contains applications compiled for the EFI architecture , which might include bootloaders for operating systems and utility software. UEFI systems include an EFI boot manager that can boot the system from a default configuration, or prompt a user to choose an operating system to boot. When a bootloader is selected, manually or automatically, UEFI reads it into memory and yields control of the boot process to it. If everything works out fine it boots but if it fails it falls back to BIOS type booting which is known as the Legacy Boot Mode . Advantages Over BIOS No limitation over size anytime soon due to 64-bit entries in GPT . UI is better (Needs to be explained a better) Provides Secure Boot feature which has been discussed below. Secure Boot","title":"BIOS & UEFI"},{"location":"OS/BIOS_UEFI/#bios","text":"The Basic Input/Output System ( BIOS ) is a firmware interface that controls not only the first step of the boot process, but also provides the lowest level interface to peripheral devices.","title":"BIOS"},{"location":"OS/BIOS_UEFI/#boot-process","text":"When the system boots, the processor looks at the end of system memory for the BIOS program , and runs it. BIOS onducts POST (Power On Self Test). Fetches MBR (Master Boot Record) from first sector of memory. MBR is 512 bytes in size MBR contains machine code instructions for booting the machine, called a boot loader, along with the partition table. BIOS loads Bootloader in RAM , the control is passed to Bootloader after the BIOS loads it. First-stage bootloader is a small machine code binary on the MBR. Its sole job is to locate the second stage boot loader (GRUB) and load the first part of it into memory.","title":"Boot Process"},{"location":"OS/BIOS_UEFI/#limitations","text":"BIOS can boot from only drives of less than or equal to 2 TB . It can't initialize multiple hardware devices at once leading to slow boot processes. Can't support advanced features like netboot .","title":"Limitations"},{"location":"OS/BIOS_UEFI/#uefi","text":"The Unified Extensible Firmware Interface (UEFI) is designed, like BIOS, to control the boot process (through boot services) and to provide an interface between system firmware and an operating system (through runtime services). Unlike BIOS, it features its own architecture, independent of the CPU, and its own device drivers. UEFI can mount partitions and read certain file systems.","title":"UEFI"},{"location":"OS/BIOS_UEFI/#boot-process_1","text":"When an x86 computer equipped with UEFI boots, the interface searches the system storage for a partition labeled with a specific globally unique identifier (GUID) that marks it as the EFI System Partition (ESP) . This partition contains applications compiled for the EFI architecture , which might include bootloaders for operating systems and utility software. UEFI systems include an EFI boot manager that can boot the system from a default configuration, or prompt a user to choose an operating system to boot. When a bootloader is selected, manually or automatically, UEFI reads it into memory and yields control of the boot process to it. If everything works out fine it boots but if it fails it falls back to BIOS type booting which is known as the Legacy Boot Mode .","title":"Boot Process"},{"location":"OS/BIOS_UEFI/#advantages-over-bios","text":"No limitation over size anytime soon due to 64-bit entries in GPT . UI is better (Needs to be explained a better) Provides Secure Boot feature which has been discussed below.","title":"Advantages Over BIOS"},{"location":"OS/BIOS_UEFI/#secure-boot","text":"","title":"Secure Boot"},{"location":"OS/vmap/","text":"Virtual Mapping of Memory","title":"Virtual Mapping"},{"location":"OS/vmap/#virtual-mapping-of-memory","text":"","title":"Virtual Mapping of Memory"},{"location":"Processor/basics/","text":"Basics of Processor design","title":"Basics"},{"location":"Processor/basics/#basics-of-processor-design","text":"","title":"Basics of Processor design"},{"location":"Projects/Archived/pcie_driver/","text":"Design of a C based PCIe driver","title":"PCIe C driver"},{"location":"Projects/Archived/pcie_driver/#design-of-a-c-based-pcie-driver","text":"","title":"Design of a C based PCIe driver"},{"location":"Projects/Current/ajit_hpc/","text":"FPGA HPC System around AJIT","title":"AJIT HPC System"},{"location":"Projects/Current/ajit_hpc/#fpga-hpc-system-around-ajit","text":"","title":"FPGA HPC System around AJIT"},{"location":"Projects/Current/iitb_risc_superscalar/","text":"IITB-RISC Superscalar Design","title":"IITB-RISC Superscalar design"},{"location":"Projects/Current/iitb_risc_superscalar/#iitb-risc-superscalar-design","text":"","title":"IITB-RISC Superscalar Design"},{"location":"Tutorials/Aa/","text":"","title":"Aa"},{"location":"Tutorials/Advanced_HLS/","text":"Advanced HLS example","title":"Advanced HLS example"},{"location":"Tutorials/Advanced_HLS/#advanced-hls-example","text":"","title":"Advanced HLS example"},{"location":"Tutorials/Basic_HLS/","text":"Basic HLS example HLS Adder A simple AXI interface AXI block. CPP file #include ap_int.h #include hls_stream.h void Adder(int data_in_1, int data_in_2, int *data_out) { #pragma HLS INTERFACE s_axilite port=data_in_1 #pragma HLS INTERFACE s_axilite port=data_in_2 #pragma HLS INTERFACE s_axilite port=data_out #pragma HLS INTERFACE s_axilite port=return *data_out = data_in_1 + data_in_2; }","title":"Basic HLS example"},{"location":"Tutorials/Basic_HLS/#basic-hls-example","text":"","title":"Basic HLS example"},{"location":"Tutorials/Basic_HLS/#hls-adder","text":"A simple AXI interface AXI block.","title":"HLS Adder"},{"location":"Tutorials/Basic_HLS/#cpp-file","text":"#include ap_int.h #include hls_stream.h void Adder(int data_in_1, int data_in_2, int *data_out) { #pragma HLS INTERFACE s_axilite port=data_in_1 #pragma HLS INTERFACE s_axilite port=data_in_2 #pragma HLS INTERFACE s_axilite port=data_out #pragma HLS INTERFACE s_axilite port=return *data_out = data_in_1 + data_in_2; }","title":"CPP file"},{"location":"Tutorials/HLS/","text":"High Level Synthesis Tools in Vivado Setup You need a CPP file where you describe your block and a tcl scipt and a Makefile to compile the project. CPP file #include ap_int.h #include hls_stream.h void Name-of-your-block (int data_in_1, int data_in_2, int *data_out) /* Port declarations similar to function arguments */ { /* pragmas to inform compiler about the type of ports */ #pragma HLS INTERFACE s_axilite port=data_in_1 #pragma HLS INTERFACE s_axilite port=data_in_2 #pragma HLS INTERFACE s_axilite port=data_out #pragma HLS INTERFACE s_axilite port=return *data_out = /* Some operation on inputs producing an output */ } tcl script open_project test set_top test add_files test.cpp open_solution test set_part {xc7vx690tffg1761-2} create_clock -period 10 -name default csynth_design export_design -format ip_catalog exit Makefile VIVADO_HLS17_1=/home/Xilinx_2017.1/Vivado_HLS/2017.1/bin/vivado_hls default: all all: hls checkpaths: @ls $(VIVADO_HLS17_1) /dev/null 2 1 || echo Error : incorrect path for vivado_hls. @ls $(VIVADO_HLS17_1) /dev/null 2 1 hls: checkpaths $(VIVADO_HLS17_1) -f hls.tcl clean: rm -rf Adder vivado_hls.log Basic Example Intermediate Example Advanced Example","title":"High Level Synthesis Tools in Vivado"},{"location":"Tutorials/HLS/#high-level-synthesis-tools-in-vivado","text":"","title":"High Level Synthesis Tools in Vivado"},{"location":"Tutorials/HLS/#setup","text":"You need a CPP file where you describe your block and a tcl scipt and a Makefile to compile the project.","title":"Setup"},{"location":"Tutorials/HLS/#cpp-file","text":"#include ap_int.h #include hls_stream.h void Name-of-your-block (int data_in_1, int data_in_2, int *data_out) /* Port declarations similar to function arguments */ { /* pragmas to inform compiler about the type of ports */ #pragma HLS INTERFACE s_axilite port=data_in_1 #pragma HLS INTERFACE s_axilite port=data_in_2 #pragma HLS INTERFACE s_axilite port=data_out #pragma HLS INTERFACE s_axilite port=return *data_out = /* Some operation on inputs producing an output */ }","title":"CPP file"},{"location":"Tutorials/HLS/#tcl-script","text":"open_project test set_top test add_files test.cpp open_solution test set_part {xc7vx690tffg1761-2} create_clock -period 10 -name default csynth_design export_design -format ip_catalog exit","title":"tcl script"},{"location":"Tutorials/HLS/#makefile","text":"VIVADO_HLS17_1=/home/Xilinx_2017.1/Vivado_HLS/2017.1/bin/vivado_hls default: all all: hls checkpaths: @ls $(VIVADO_HLS17_1) /dev/null 2 1 || echo Error : incorrect path for vivado_hls. @ls $(VIVADO_HLS17_1) /dev/null 2 1 hls: checkpaths $(VIVADO_HLS17_1) -f hls.tcl clean: rm -rf Adder vivado_hls.log Basic Example Intermediate Example Advanced Example","title":"Makefile"},{"location":"Tutorials/Intermediate_HLS/","text":"Intermediate HLS example","title":"Intermediate HLS example"},{"location":"Tutorials/Intermediate_HLS/#intermediate-hls-example","text":"","title":"Intermediate HLS example"},{"location":"Tutorials/VHDL/","text":"","title":"VHDL"},{"location":"Tutorials/build_tools/","text":"Build Systems Make tools Auto tools Useful Link CMake Python Based Meson build system","title":"Build Systems"},{"location":"Tutorials/build_tools/#build-systems","text":"","title":"Build Systems"},{"location":"Tutorials/build_tools/#make-tools","text":"","title":"Make tools"},{"location":"Tutorials/build_tools/#auto-tools","text":"Useful Link","title":"Auto tools"},{"location":"Tutorials/build_tools/#cmake","text":"","title":"CMake"},{"location":"Tutorials/build_tools/#python-based","text":"","title":"Python Based"},{"location":"Tutorials/build_tools/#meson-build-system","text":"","title":"Meson build system"},{"location":"Tutorials/intro/","text":"Tutorials Vivado HLS Tutorials Here I first present a beginner level tutorial of Vivado HLS, where we will build a simple Adder HDL block through basically what would be a C++ program. And from there on we move to more advanced examples of designing Stream FIFOs and their AXI controllers. Then we move on to designing a Memory Address Translator Block which can read and write the memory through address translation. Aa HLS Here we discuss some basic VHDL blocks generated through Aa HLS ( known as AHIR ) and how to simulate them in software and hardware. I will also discuss some of the semantics of Aa here. VHDL Examples Here we discuss some basic VHDL examples and how to simulate them in gtkwave. I will also discuss some of the useful semantics of VHDL here. Introduction to Build Systems Here we discuss some build systems and how to setup a basic project for each of them. We will also discuss some advantages of each over other build alternatives.","title":"Tutorials"},{"location":"Tutorials/intro/#tutorials","text":"","title":"Tutorials"},{"location":"Tutorials/intro/#vivado-hls-tutorials","text":"Here I first present a beginner level tutorial of Vivado HLS, where we will build a simple Adder HDL block through basically what would be a C++ program. And from there on we move to more advanced examples of designing Stream FIFOs and their AXI controllers. Then we move on to designing a Memory Address Translator Block which can read and write the memory through address translation.","title":"Vivado HLS Tutorials"},{"location":"Tutorials/intro/#aa-hls","text":"Here we discuss some basic VHDL blocks generated through Aa HLS ( known as AHIR ) and how to simulate them in software and hardware. I will also discuss some of the semantics of Aa here.","title":"Aa HLS"},{"location":"Tutorials/intro/#vhdl-examples","text":"Here we discuss some basic VHDL examples and how to simulate them in gtkwave. I will also discuss some of the useful semantics of VHDL here.","title":"VHDL Examples"},{"location":"Tutorials/intro/#introduction-to-build-systems","text":"Here we discuss some build systems and how to setup a basic project for each of them. We will also discuss some advantages of each over other build alternatives.","title":"Introduction to Build Systems"}]}